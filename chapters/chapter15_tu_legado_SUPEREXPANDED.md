# Capítulo 15: Tu Legado en Código

Hace un mes, recibí un email que me hizo llorar.

Era de un developer en India que nunca conocí. Me decía que tres años atrás había leído un blog post mío sobre debugging. Era junior, estaba luchando con un bug que lo estaba destrozando, y estaba considerando dejar la programación.

Mi post le mostró una forma diferente de pensar sobre el problema. Resolvió el bug. Más importante: entendió que debugging no es sobre ser brillante, es sobre ser metódico.

Hoy es senior developer. Y me escribía para decirme gracias.

Yo ni recordaba haber escrito ese post. Fueron tal vez dos horas de mi vida, un sábado por la tarde. Pero para él, cambió todo.

Eso es legado.

No código que va a vivir forever. Ni frameworks que van a ser usados por millones. Sino el impacto que tenés en otras personas. Las formas en que, directa o indirectamente, hacés que el mundo (o al menos una pequeña parte de él) sea mejor.

Este es el capítulo más personal del libro. Porque al final, después de todos los frameworks y las optimizaciones y las mejores prácticas, queda una pregunta:

¿Por qué hacemos esto? ¿Qué queremos que quede cuando nos vayamos?

## Por qué realmente programamos (más allá del salario)

Cuando empecé a programar, lo hacía por razones pragmáticas: buenos salarios, trabajo remote, demanda laboral.

Y sí, esas cosas importan. No voy a romantizarlo. Poder pagar las cuentas, vivir cómodamente, tener flexibilidad... eso no es trivial.

Pero después de años programando, descubrí que las razones por las que continúo no son las razones por las que empecé.

Continúo porque:

**1. Creamos cosas de la nada**

Hay algo profundamente satisfactorio en abrir un archivo vacío y, horas después, tener un sistema funcionando. Materializar ideas en realidad ejecutable.

No muchas profesiones tienen ese poder. Un escritor escribe un libro que algunos leerán. Un músico compone una canción que algunos escucharán.

Pero nosotros... nosotros creamos herramientas que la gente USA. Sistemas que procesan millones de transacciones. Aplicaciones que conectan personas. Código que mueve dinero, salva vidas, educa niños.

Es magia. Literal magia. Escribimos texto en un archivo y se convierte en algo que hace cosas en el mundo real.

**2. Resolvemos problemas que importan**

Cada bug que fixeás, cada feature que implementás, cada sistema que optimizás... está resolviendo un problema real para alguien.

Tal vez es un usuario que ahora puede hacer su trabajo más rápido. Tal vez es un equipo que ahora puede escalar su sistema. Tal vez es una abuela que puede ver fotos de sus nietos más fácilmente.

Nuestro trabajo no es abstracto. Es profundamente práctico. Y eso le da significado.

**3. Aprendemos constantemente**

Si te gusta aprender, programming es el trabajo perfecto. Porque nunca parás. Cada proyecto es un nuevo problema. Cada tecnología evoluciona. Cada sistema es diferente.

Podés trabajar 30 años y seguir aprendiendo cosas nuevas. No muchas carreras ofrecen eso.

**4. Construimos el futuro**

Todo lo que hacemos hoy se convierte en infraestructura del mañana. El código que escribís hoy puede estar corriendo sistemas dentro de 10 años. Las decisiones arquitectónicas que tomás hoy determinan qué es posible mañana.

Somos, literalmente, arquitectos del futuro digital.

Y eso... eso es más grande que un salario.

## Daniel Pink y las tres necesidades humanas

Daniel Pink escribió un libro llamado "Drive" sobre motivación humana. Estudió qué hace que la gente esté satisfecha con su trabajo a largo plazo.

Su conclusión: después de cierto punto, el dinero no es el motivador principal. Lo que realmente importa son tres cosas:

**1. Autonomía - Control sobre tu trabajo**

La sensación de que elegís qué hacer, cómo hacerlo, cuándo hacerlo. No que alguien te esté micromanaging cada decisión.

Programming, cuando está bien hecho, ofrece mucha autonomía. Tenés un problema, elegís la solución. Diseñás la arquitectura. Decidís qué herramientas usar.

Los mejores trabajos de programming son los que te dan ownership real. "Acá está el problema, resuelvelo como creas mejor."

**2. Mastery - Mejora continua en algo que importa**

La sensación de que estás mejorando en algo difícil y valioso. Que hoy sos mejor que hace un año.

Programming es perfecto para esto. Siempre hay un nivel más de profundidad. Siempre podés ser mejor. Y podés ver tu progreso: código que antes te tomaba una semana ahora te toma un día.

**3. Purpose - Trabajar en algo más grande que vos**

La sensación de que tu trabajo importa. Que contribuye a algo significativo.

Esto es lo que más developers pierden de vista. Nos enfocamos tanto en el código que olvidamos el propósito.

Pero el código sin propósito es solo texto. Es cuando el código HACE algo que importa a alguien que se vuelve meaningful.

Pink demostró esto con research: developers que sienten que su trabajo tiene purpose reportan 3x más satisfacción laboral que los que solo ven su trabajo como "implementar features".

No necesitás estar curando cáncer. Pero necesitás conectar tu trabajo con su impacto real.

Si estás construyendo un e-commerce, no estás "haciendo CRUD". Estás ayudando a small businesses a vender online, lo cual les cambia la vida.

Si estás construyendo un sistema de pagos, no estás "moviendo dinero". Estás haciendo que la gente pueda comprar lo que necesita de forma segura.

Reframe el purpose. Y tu trabajo se vuelve más significativo.

## Open Source: El legado que trasciende compañías

Hay una forma de legado que es única en programming: open source.

Código que escribís no para una compañía, sino para el mundo. Librería que cualquiera puede usar. Herramientas que otros pueden mejorar.

Y cuando lo hacés bien, ese código te outlives. Literalmente.

**Linux:**

En 1991, un estudiante finlandés de 21 años llamado Linus Torvalds empezó a escribir un operating system "solo como hobby". Lo compartió gratuitamente.

Hoy, Linux corre en el 90% de los servidores del mundo. Cada aplicación que usás, cada sitio web que visitás, probablemente está corriendo en Linux.

Linus cambió el mundo. No vendiendo su código. Regalándolo.

**React:**

En 2013, un developer en Facebook (Jordan Walke) estaba frustrado con cómo se construían UIs. Creó una librería interna. Facebook la open-sourced en 2013.

Hoy, millones de developers usan React. Millones de websites están construidos con React. Jordan cambió cómo se construye el web.

**Vue:**

Evan You trabajaba en Google. Le gustaba Angular pero pensaba que era demasiado complejo. En su tiempo libre, empezó a construir algo más simple.

Lanzó Vue en 2014. Sin el backing de una company grande. Solo un developer con una idea.

Hoy, Vue es uno de los frameworks más usados del mundo. Evan se mantiene a sí mismo con donaciones y sponsorships. Y cambió el ecosistema frontend.

No necesitás crear Linux o React. Pero podés contribuir. Podés mejorar algo que otros usan. Podés escribir una librería pequeña que resuelve un problema específico brillantemente.

**GitHub 2023 data:**

Según el State of the Octoverse 2023:
- 100+ millones de developers en GitHub
- 90+ millones de repositories creados ese año
- 400+ millones de contributions (commits, PRs, issues)

Open source no es un nicho. Es cómo se construye software en el siglo 21.

Y cada contribution, por pequeña que sea, es legado. Es código que va a vivir más allá de tu current job, tu current company, incluso más allá de tu carrera.

Mi primera contribution a open source fue fixing un typo en documentación. Literal, cambié "teh" por "the". Pull request de una línea.

Trivial. Pero me enseñó el proceso. La siguiente contribution fue un bug fix. La siguiente, una feature.

Hoy tengo código corriendo en libraries con millones de downloads. No porque sea brillante. Porque empecé pequeño y fui consistente.

## Tu código después de que te vayas

Acá hay algo que suena mórbido pero es importante: eventualmente, todos nos vamos.

Nos vamos de una compañía. Nos retiramos. Morimos.

Y el código que escribiste... ¿qué pasa con él?

La realidad: la mayoría del código que escribimos va a ser borrado o reescrito dentro de 5-10 años. Eso no es malo, es normal. La tecnología evoluciona. Los requirements cambian.

Pero lo que SÍ perdura es:

**1. El conocimiento que compartiste**

Ese blog post que escribiste explicando cómo resolver un problema. Ese comment en Stack Overflow. Esa presentación en una conference.

Eso vive más allá del código. Y potencialmente ayuda a cientos o miles de developers que nunca vas a conocer.

**2. Los sistemas que diseñaste bien**

Si diseñaste una arquitectura sólida, con buenos principles, eso influencia decisiones por años. Incluso cuando el código específico se reemplaza, los patterns que estableciste persisten.

**3. Las personas que mentoreaste**

Esto es el legado más duradero. Un junior que ayudaste a crecer se convierte en senior. Ese senior mentoreá a otros juniors. Y así, tu influencia se multiplica exponencialmente.

Hay developers que mentoree hace 5 años que hoy son tech leads. Y ellos mentorean a sus teams con principles que aprendieron de mí (que aprendí de otros). Es una cadena.

Tu legado no es tu código. Es la gente que tocaste.

## Mentoring: Cómo una conversación cambió mi carrera (y cómo podés hacer lo mismo por otros)

Año 2015. Estaba en el año 4 de mi carrera. Me sentía estancado. Cada día era igual: implementar features, fix bugs, repeat.

Un senior en mi equipo, Gabriel, notó mi frustración. Me invitó a tomar café. Me preguntó qué me pasaba.

Le expliqué: siento que no estoy creciendo. Que estoy en piloto automático.

Gabriel no me dio soluciones. Me hizo preguntas:
- ¿Qué querés aprender que no estás aprendiendo?
- ¿Qué tipo de problemas te gustaría resolver?
- ¿Dónde te ves en 3 años?

Y después: "Si pudieras trabajar en cualquier proyecto en la compañía, ¿cuál sería?"

Había un proyecto de refactoring de nuestra arquitectura de microservicios que me fascinaba. Pero era "senior work", o eso pensaba.

Gabriel dijo: "Yo estoy liderando ese proyecto. ¿Querés unirte? Va a ser difícil. Vas a estar fuera de tu comfort zone. Pero vas a aprender todo lo que estás buscando."

Esa conversación cambió mi carrera. El proyecto fue brutal. Lloré frente a mi laptop más de una vez. Pero aprendí distributed systems, system design, trade-offs arquitectónicos.

Dos años después, era tech lead. Por ese proyecto.

Todo porque Gabriel se tomó 30 minutos para hablar conmigo.

**Ahora yo hago lo mismo.**

Una vez al mes, hablo con un junior o mid-level developer. No formal mentorship. Solo una conversación.

Les hago las preguntas que Gabriel me hizo. Les señalo oportunidades que tal vez no ven. Les ofrezco trabajar conmigo en algo challenging si están interesados.

No todos aceptan. Algunos no están ready. Y está bien.

Pero los que sí... veo su crecimiento. Y es una de las cosas más satisfactorias de mi carrera.

No porque me haga quedar bien. Porque estoy paying forward lo que Gabriel hizo por mí.

**Si sos senior (o incluso mid-level):**

Hay juniors que te admiran y podrían aprender de vos. No necesitan que los "mentoreés" formalmente. Necesitan que los notes. Que les des una chance.

Una conversación de 30 minutos puede cambiar la trayectoria de su carrera. Y literalmente te toma 30 minutos.

## Technical Writing: El blog post que cambió vidas (incluyendo la mía)

En 2017 tuve un bug particularmente frustrante. Un race condition en un sistema distribuido que solo aparecía en producción bajo carga alta. Me tomó dos semanas resolverlo.

Cuando finalmente lo entendí, el relief fue enorme. Y pensé: "Alguien más va a tener este mismo problema. Y no debería tener que sufrir dos semanas para encontrar la solución."

Así que escribí un blog post. 2,000 palabras explicando el problema, por qué era difícil de debuggear, y cómo lo resolví.

Lo publiqué en Medium. Lo compartí en Twitter. Tal vez 50 personas lo leyeron.

Durante el siguiente año, olvidé que ese post existía.

Hasta que empezaron a llegar emails. Gente agradeciéndome. "Tu post me salvó días de debugging." "Tenía exactamente el mismo problema y tu solution funcionó."

En cinco años, ese post ha sido leído por más de 15,000 personas (según Medium analytics). He recibido probablemente 30 emails de gente agradeciéndome.

Y ese post me abrió oportunidades: conference talks, job offers, collaborations.

Todo porque me tomé dos horas un domingo para documentar algo que aprendí.

**The compound effect of writing:**

Cada blog post es un asset. Se sienta ahí, en internet, ayudando a gente 24/7 sin que vos hagas nada.

Escribís un post hoy. En cinco años, ha ayudado a 10,000 personas. Eso es 10,000 horas de frustración que ahorraste. Es 10,000 problemas resueltos.

Y la mayoría de esa gente nunca te va a agradecer. No van a comentar. Pero su vida fue un poco mejor porque vos te tomaste el tiempo de escribir.

Eso es legado.

**No necesitás ser un "escritor"**

El pensamiento que me frenó por años: "No soy bueno escribiendo. No tengo nada interesante que decir."

Mentira en ambos casos.

No necesitás ser Hemingway. Necesitás ser claro. Y cualquiera puede aprender claridad (es más fácil que aprender algoritmos).

Y sí, tenés cosas interesantes que decir. Cada problema que resolvés, cada bug que debuggueás, cada decision arquitectónica que tomás... es potencialmente útil para alguien más.

**El framework "TIL" (Today I Learned):**

No pensés en "voy a escribir un artículo técnico exhaustivo". Pensá en "voy a documentar algo que aprendí hoy".

- Aprendiste que X library tiene un quirk con Y? Escribí 200 palabras sobre eso.
- Descubriste una forma mejor de hacer Z? Escribí 400 palabras.
- Resolviste un bug raro? Escribí cómo.

No necesita ser un essay de 3000 palabras. Puede ser un gist de GitHub con 300 palabras.

Lo importante es: compartí lo que aprendiste. Porque alguien, en algún lugar, va a estar googleando exactamente ese problema.

Y tu post va a ser la respuesta que necesitan.

## Building systems people love (developer joy es un feature)

Hay una diferencia entre código que funciona y código que la gente DISFRUTA usar.

La mayoría del código que escribimos es puramente functional. Hace lo que tiene que hacer. Nada más.

Pero cada tanto, usás una library o framework o tool que te hace sonreír. Que está pensado para developer experience. Que anticipa tus necesidades.

Esos son los proyectos que la gente recuerda. Los que generan comunidades. Los que cambian industrias.

**Ejemplos:**

**Rails (Ruby on Rails):**

Cuando David Heinemeier Hansson creó Rails en 2004, había muchos web frameworks. Pero Rails era diferente. No solo funcionaba. Era un PLACER usarlo.

"Convention over configuration." Magic que funciona. Naming intuitivo. Mensajes de error útiles.

Rails no ganó por ser el más performante o el más flexible. Ganó porque hacía feliz a developers.

**Stripe:**

Antes de Stripe, integrar pagos era un nightmare. Documentación terrible. APIs confusas. Debugging imposible.

Stripe llegó con: documentación hermosa, APIs intuitivas, error messages claros, test mode fácil.

Hoy vale $95 billion. No porque su tecnología es mágicamente superior. Porque priorizaron developer experience.

**Tailwind CSS:**

Adam Wathan no inventó CSS utilities. Pero Tailwind lo hizo de forma que te GUSTA usar.

Naming consistente. Defaults sensatos. Documentación impecable. Sistema de design coherente.

Result: millones de developers lo adoptan. No porque lo necesitan. Porque lo disfrutan.

**El principle común:**

Estos productos no solo resuelven un problema. Lo resuelven de forma que el developer se siente cuidado.

Y cuando la gente se siente cuidada, se vuelven advocates. Escriben blogs. Dan talks. Refieren a otros.

**Cómo aplicar esto:**

No estás construyendo un framework usado por millones. Pero podés aplicar el mismo principle a tu trabajo:

**Si construís una API interna:**
- ¿Los endpoints son intuitivos?
- ¿Los error messages son útiles o crípticos?
- ¿Documentaste casos edge?
- ¿Es fácil para un nuevo developer entender cómo usarla?

**Si construís una library:**
- ¿El getting started toma 5 minutos o 5 horas?
- ¿Los names son descriptivos o confusos?
- ¿Anticipaste los use cases comunes?

**Si construís una herramienta de deploy:**
- ¿Cuando falla, le da al usuario información útil para fixearlo?
- ¿O tira un stack trace y "buena suerte"?

La diferencia entre código que funciona y código que la gente ama está en los detalles que muestran que te importa la experiencia del usuario.

Y en nuestro caso, ese usuario es otro developer.

Developer joy no es un nice-to-have. Es un multiplier. Code que es un placer usar se usa más, se mantiene mejor, y genera más value.

## El código que escribiste que no sabés que importó

Esto es lo más hermoso y lo más frustrante del legado en programming: muchas veces no sabés cuándo hiciste algo que importó.

Ese code review donde sugeriste una mejor abstracción. El junior miró tu sugerencia, aprendió un pattern nuevo, y ahora lo usa en todo lo que hace.

Ese bug fix que submiteaste a un proyecto open source. Previno que 10,000 personas tuvieran ese bug.

Ese refactor que hiciste que hizo el código más legible. El próximo developer que trabajó en ese código terminó más rápido porque vos lo dejaste limpio.

**La mayoría del impacto es invisible.**

Y eso puede sentirse frustrante. Queremos feedback. Queremos saber que nuestro trabajo importó.

Pero la realidad es: tu trabajo está importando constantemente de formas que nunca vas a saber.

Y tenés que hacer paz con eso. Hacer buen trabajo no por el reconocimiento, sino porque es lo correcto.

## Si murieras mañana, ¿qué quedaría?

Esta es una pregunta mórbida pero útil: si te fueras mañana (de la compañía, de la industria, de la vida), ¿qué quedaría de tu paso por programming?

Para algunos: nada tangible. Su código va a ser reescrito. Sus projects, deprecados.

Para otros: conocimiento compartido. Gente mentoreada. Proyectos open source. Comunidades construidas.

No te estoy diciendo que seas Mother Teresa del código. Pero sí que pienses: ¿qué estás construyendo que va a outlive tu tenure actual?

**Formas de crear legado duradero:**

**1. Enseñá**

Blog posts, videos, talks, workshops, mentoring. Conocimiento compartido vive forever.

**2. Contribuí a open source**

Código que otros pueden usar y mejorar. El gift que keeps giving.

**3. Construí herramientas que hagan la vida de otros developers más fácil**

Una CLI tool útil. Una library pequeña pero bien hecha. Una configuración de eslint que otros pueden reusar.

**4. Mejorá procesos y cultura en tu equipo**

Establecé code review guidelines. Documentá tribal knowledge. Creá onboarding materials.

Estas cosas sobreviven tu partida y hacen la vida mejor para los que vienen después.

**5. Mentorea explícita o implícitamente**

Dale feedback constructivo. Compartí cómo pensás sobre problemas. Hacé pair programming con juniors.

La gente que ayudaste a crecer es tu legado más duradero.

## El propósito más allá del código

Acá está la verdad final: el código es solo el medio. El propósito es el impacto.

No importa si escribís el código más elegante del mundo si no resuelve un problema real para alguien.

Y "resolver un problema" puede ser:
- Hacer que un proceso sea más rápido (le ahorrás tiempo a la gente)
- Hacer que una interfaz sea más intuitiva (le ahorrás frustración a la gente)
- Hacer que un sistema sea más confiable (le ahorrás stress a la gente)

O puede ser algo más grande:
- Construir herramientas que educan
- Sistemas que conectan personas
- Plataformas que empoderan small businesses
- Software que hace healthcare más accesible

No tenés que estar curando el cáncer. Pero necesitás ver tu trabajo más allá del código.

Cuando trabajaba en un e-commerce, no era "solo implementar shopping cart". Era ayudar a small businesses a competir con Amazon. A familias a comprar productos que necesitan desde su casa.

Cuando trabajaba en una plataforma de education, no era "solo construir video streaming". Era hacer que educación de calidad esté disponible para gente que no puede pagar universidades caras.

El purpose le da significado al trabajo. Y el significado hace el trabajo sostenible.

**Viktor Frankl, sobreviviente del Holocausto y psychiatrist, escribió:**

"Los que tenemos un por qué para vivir, podemos soportar casi cualquier cómo."

Aplicado a programming: si tenés un propósito claro (por qué estás haciendo esto, a quién estás ayudando), podés soportar los días difíciles. Los bugs frustrantes. El código legacy. Las reuniones aburridas.

Porque sabés que detrás de todo eso, hay gente siendo ayudada.

## Tu legado empieza hoy

No tenés que esperar 10 años de carrera para empezar a construir legado.

Podés empezar hoy:

- Escribí un blog post sobre algo que aprendiste esta semana
- Ayudá a un junior con un problema que estén teniendo
- Contribuí a un proyecto open source (aunque sea fixing typos)
- Hacé code review constructivo que enseñe, no solo critique
- Documentá algo que solo existe en tribal knowledge

Cada uno de estos actos es pequeño. Toma minutos u horas.

Pero compuestos over time, se convierten en legado.

## El privilegio de construir

Hay algo que quiero que veas: estás en una posición de enorme privilegio.

Sos developer en el siglo 21. Eso significa:
- Tenés una skill extremadamente demandada
- Ganás (probablemente) más que el 90% de la población mundial
- Tenés la capacidad de crear cosas que millones pueden usar
- Tenés acceso a una cantidad infinita de conocimiento gratuito
- Podés trabajar desde cualquier lugar con internet

No everyone tiene esto.

Y con privilegio viene responsabilidad.

No necesitás salvar el mundo. Pero podés hacer tu pequeña parte: compartir lo que sabés, ayudar a quien podés, construir cosas que importan.

## Una conversación que tuve con un developer de 60 años

Hace dos años, en una conference, conocí a un developer de 60 años. Bob. Había estado programando desde los 80s.

Le pregunté: "Después de 40 años programando, ¿qué es lo que más te importa ahora?"

Bob me dijo:

"Durante años, me importaba escribir el código más elegante. Estar en el bleeding edge. Ser el más técnico en la room.

Eso está bien cuando sos joven. Pero eventualmente te das cuenta: el código es efímero. Las tecnologías van y vienen. Lo que realmente importa es la gente.

Los juniors que mentoree que ahora son VPs de engineering. Los proyectos open source donde colaboré que todavía se usan. Los developers que inspiré a seguir en la industria cuando querían renunciar.

Ese es el trabajo que me enorgullece. No el código más elegante que escribí (que ya fue refactorizado tres veces). Sino las vidas que toqué."

Esa conversación me cambió.

Porque vi mi futuro: en 30 años, cuando esté viejo y probablemente ya no esté programando activamente, ¿de qué voy a estar orgulloso?

No de los frameworks que usé o los salarios que gané.

Sino de la gente que ayudé. Del conocimiento que compartí. De los problemas reales que resolví.

Ese es el legado que importa.

## Tu llamado a la acción

Este es el último capítulo del libro. Después de esto, solo el epílogo.

Así que dejame decirte esto directamente:

**Sos un developer en el momento más emocionante de la historia de software.**

La AI está revolucionando cómo trabajamos. Los problemas que estamos resolviendo (cambio climático, healthcare, educación) son más grandes que nunca. Las herramientas a nuestra disposición son increíbles.

Y vos tenés un rol en esto.

No tenés que ser el próximo Linus Torvalds. No tenés que crear el próximo React.

Pero podés:
- Escribir código que resuelve problemas reales
- Compartir lo que aprendés
- Ayudar a otros a crecer
- Construir con intención y propósito

Y si hacés eso, consistentemente, por años...

Tu legado no va a ser el código que escribiste. Va a ser el impacto que tuviste.

En los sistemas que construiste. En la gente que ayudaste. En el conocimiento que compartiste.

**Ese es el legado que vale la pena.**

## Tres compromisos para hacer hoy

No "tres experimentos para esta semana". No "tres ejercicios para probar".

Sino tres compromisos. Con vos mismo. Con tu carrera. Con tu legado.

**Compromiso #1: Voy a compartir lo que aprendo**

No necesitás un blog fancy. Puede ser gists de GitHub, Twitter threads, o Google Docs compartidos.

Pero cuando aprendas algo valioso, lo vas a documentar. Porque alguien, en algún lugar, va a necesitar exactamente esa información.

**Compromiso #2: Voy a ayudar a alguien a crecer**

Una vez al mes (o semana, o trimestre, depending tu bandwidth), vas a invertir tiempo en ayudar a alguien que sabe menos que vos.

Code review educativo. Mentoring informal. Responder preguntas con paciencia.

Tu conocimiento no te hace más valioso si lo guardás. Te hace más valioso cuando lo multiplicás.

**Compromiso #3: Voy a construir con propósito**

No solo "implementar features". Sino entender el por qué. A quién ayuda. Qué problema resuelve.

Y cuando sea posible, elegir trabajar en cosas que importan. Problemas que genuinamente te interesen. Productos que hacen el mundo un poco mejor.

---

Tu carrera es más que una secuencia de jobs. Es una oportunidad de impacto.

El código que escribís hoy puede ser reescrito mañana. Pero las personas que ayudaste, el conocimiento que compartiste, los problemas que resolviste...

Eso vive.

Ese es tu legado.

Y empieza hoy.

No cuando seas senior. No cuando tengas 10 años de experiencia. No "algún día".

Hoy.

Porque resulta que el código no es lo que dejamos atrás.

Es la diferencia que hacemos.

Y vos, developer leyendo esto... tenés el poder de hacer una diferencia.

Usalo bien.
